# 为什么并发编程如此困难

众所周知，编写并发代码十分困难，通常需要经过多次迭代才能使代码按预期运行。即使代码按预期运行了，也会长期存在（潜伏）着一些 bug ，直到随着时间的推移产生了一些变化（越来越多的磁盘利用率、越来越多的用户登陆系统），才导致以前未发现的bug凸显出来，这种情况是普遍存在的。事实上，在这本书中，我会尽可能多地关注代码，试图减少这种情况的发生。

幸运的是，每个人在处理并发代码时都会遇到同样的问题
正因如此，计算机科学家们标记出这些常见的问题，让我们能够讨论这些问题是如何产生的，为什么要解决以及如何解决这些问题。
让我们开始吧。以下是一些最常见的问题，这些问题使得处理并发代码既令人沮丧又有趣
## 竞态/竞态条件/竞争状态（Race Conditions）
A race condition or race hazard is the condition of an electronics, software, or other system where the system's substantive behavior is dependent on the sequence or timing of other uncontrollable events. It becomes a bug when one or more of the possible behaviors is undesirable.
当两个或两个以上的操作必须以正确的秩序执行，但没有编写程序以保证这个秩序的时候，就会发生竞态。

大多数情况下，这会出现在所谓的数据竞争（data race）中，即：一个并发操作试图读取一个变量，同时在某个不确定的时间里，另一个并发操作试图写入同一个变量。

一个基本的例子：
```go
1	var data int
2	go func() { //①
3		data++
4	}()
5	if data == 0 {
6		fmt.Printf("the value is %v.\n", data)
	}
```
① 在 Go 中，你可以使用 `go` 关键字并发地运行一个函数。这样做就产生了所谓的 `goroutine` 。我们将在第37页的 "Goroutines" 一节详细讨论这个问题。
>译者注：该段程序是在main()中，本身就产生了一个`goroutine`,使用 go 关键字后会产生另一个`goroutine`并发地运行另外一个函数，而main()函数同时会继续向下执行 if 语句，我们无法确定这两个并行的函数（`goroutine`）的执行速度，所以也无法确定它们访问变量`data`的顺序

在这里，第3行和第5行都试图访问变量`data`，但是不能确保这可能会以什么样的顺序发生。运行这段代码有三种可能的结果:

•不打印任何东西。在本例中，先执行第3行，再执行第5行。
•打印“the value is 0”。在本例中，先执行第5行和第6行，再执行第3行。
•打印“the value is 1”。在本例中，先执行第5行，再执行第3行，之后再执行第6行。

如你所见，仅仅几行错误的代码就会给您的程序带来极大的可变性。

大多数情况下，数据竞争是由于开发人员按顺序的思维考虑问题而引入的。他们认为一行代码在另一行代码之前出现，所以会先执行，所以会认为上面的goroutine会先被调度并执行，然后才在 if 语句中读取变量 data 。

在编写并发代码时，您必须仔细地遍历可能出现的场景。除非你使用了一些我们将在本书后面介绍的技术，否则你不能保证你的代码将按照源代码中列出的顺序执行。我有时发现想象两次操作之间有一段很长的时间会很有用。 如果goroutine成功执行和程序到达if语句之间需要一个小时，会怎样? 该程序的其余部分如何运作？ 以这种方式思考对我有所帮助，因为对于计算机而言，时间的尺度可能不同，但相对时间的差异是相同的。

实际中，一些开发人员会陷入到给代码添加睡眠机制 (sleep) 的陷阱中,因为这似乎能解决并发性问题。让我们在先前的程序中试一试

```go
1 var data int
2 go func() { data++ }()
3 time.Sleep(1*time.Second) // This is bad!
4 if data == 0 {
5     fmt.Printf("the value is %v.\n" data)
6 }
```
我们解决了数据竞争了吗?不。事实上，这个程序仍然有可能产生所有三个结果，只不过减小了可能性。我们在调用goroutine和判断 data 值之间的睡眠时间越长，我们的程序就离正确越近——但这种概率只是逐渐接近逻辑上的正确，但在逻辑上永远不会正确。

除此之外，我们现在在算法中引入了低效率的问题。我们现在不得不睡眠 1 秒，这样我们就更有可能看不到我们的数据竞争。如果我们使用正确的工具，我们可能根本不需要等待，或者可能只需要等待 1 微秒。

这里的结论是，你应该始终以逻辑正确性为目标。在代码中引入睡眠机制是方便调试并发程序的一种方法，但不是解决方案。

竞态是并发中最隐蔽的一类 bug ，因为它们可能会在代码投入生产数年之后才出现。它们通常是由代码执行环境的变化或前所未有的事件引起的。在这些情况下，代码似乎是正确运作的，但实际上，操作很有可能是按顺序执行的。这个程序迟早会产生意想不到的结果。

## 原子（automatic）
当某个东西被认为是原子的，或具有原子性的属性时，这意味着在它运行的context（上下文/环境，关于context这个词，我认为在计算机领域里翻译为环境/运行环境会更恰当）中，它是不可分割的，或不可中断的。

那么这意味着什么?为什么在处理并发代码时了解这一点很重要?

首先非常重要的事情是这个词 "context",某些东西在一个context(运行环境)中可能是原子的，但在另一个context中则不是。在进程的运行环境中是原子的操作，在操作系统的运行环境中可能不是原子的；在操作系统的运行环境中是原子的操作，在机器的运行环境中可能不是原子的；在机器的运行环境中是原子的操作，在应用程序的运行环境中可能不是原子的。换句话说，操作的原子性可以根据当前定义的作用域而改变。

这个事实对你有利也有弊!

在考虑原子性时，通常需要做的第一件事是定义可以认定操作为原子的上下文或范围。一切都依据于此