# 为什么并发编程如此困难

众所周知，编写并发代码十分困难，通常需要经过多次迭代才能使代码按预期运行。即使代码按预期运行了，也会长期存在（潜伏）着一些 bug ，直到随着时间的推移产生了一些变化（越来越多的磁盘利用率、越来越多的用户登陆系统），才导致以前未发现的bug凸显出来，这种情况是普遍存在的。事实上，在这本书中，我会尽可能多地关注代码，试图减少这种情况的发生。

幸运的是，每个人在处理并发代码时都会遇到同样的问题
正因如此，计算机科学家们标记出这些常见的问题，让我们能够讨论这些问题是如何产生的，为什么要解决以及如何解决这些问题。
让我们开始吧。以下是一些最常见的问题，这些问题使得处理并发代码既令人沮丧又有趣
## 竞态/竞态条件/竞争状态（Race Conditions）
A race condition or race hazard is the condition of an electronics, software, or other system where the system's substantive behavior is dependent on the sequence or timing of other uncontrollable events. It becomes a bug when one or more of the possible behaviors is undesirable.
当两个或两个以上的操作必须以正确的秩序执行，但没有编写程序以保证这个秩序的时候，就会发生竞态。

大多数情况下，这会出现在所谓的数据竞争（data race）中，即：一个并发操作试图读取一个变量，同时在某个不确定的时间里，另一个并发操作试图写入同一个变量。

一个基本的例子：
```go
1	var data int
2	go func() { //①
3		data++
4	}()
5	if data == 0 {
6		fmt.Printf("the value is %v.\n", data)
	}
```
① 在 Go 中，你可以使用 `go` 关键字并发地运行一个函数。这样做就产生了所谓的 `goroutine` 。我们将在第37页的 "Goroutines" 一节详细讨论这个问题。
>译者注：该段程序是在main()中，本身就产生了一个`goroutine`,使用 go 关键字后会产生另一个`goroutine`并发地运行另外一个函数，而main()函数同时会继续向下执行 if 语句，我们无法确定这两个并行的函数（`goroutine`）的执行速度，所以也无法确定它们访问变量`data`的顺序

在这里，第3行和第5行都试图访问变量`data`，但是不能确保这可能会以什么样的顺序发生。运行这段代码有三种可能的结果:

•不打印任何东西。在本例中，先执行第3行，再执行第5行。
•打印“the value is 0”。在本例中，先执行第5行和第6行，再执行第3行。
•打印“the value is 1”。在本例中，先执行第5行，再执行第3行，之后再执行第6行。

如你所见，仅仅几行错误的代码就会给您的程序带来极大的可变性。

大多数情况下，数据竞争是由于开发人员按顺序的思维考虑问题而引入的。他们认为一行代码在另一行代码之前出现，所以会先执行，所以会认为上面的goroutine会先被调度并执行，然后才在 if 语句中读取变量 data 。

在编写并发代码时，您必须仔细地遍历可能出现的场景。除非你使用了一些我们将在本书后面介绍的技术，否则你不能保证你的代码将按照源代码中列出的顺序执行。我有时发现想象两次操作之间有一段很长的时间会很有用。 如果goroutine成功执行和程序到达if语句之间需要一个小时，会怎样? 该程序的其余部分如何运作？ 以这种方式思考对我有所帮助，因为对于计算机而言，时间的尺度可能不同，但相对时间的差异是相同的。

实际中，一些开发人员会陷入到给代码添加睡眠机制 (sleep) 的陷阱中,因为这似乎能解决并发性问题。让我们在先前的程序中试一试

```go
1 var data int
2 go func() { data++ }()
3 time.Sleep(1*time.Second) // This is bad!
4 if data == 0 {
5     fmt.Printf("the value is %v.\n" data)
6 }
```
我们解决了数据竞争了吗?不。事实上，这个程序仍然有可能产生所有三个结果，只不过减小了可能性。我们在调用goroutine和判断 data 值之间的睡眠时间越长，我们的程序就离正确越近——但这种概率只是逐渐接近逻辑上的正确，但在逻辑上永远不会正确。

除此之外，我们现在在算法中引入了低效率的问题。我们现在不得不睡眠 1 秒，这样我们就更有可能看不到我们的数据竞争。如果我们使用正确的工具，我们可能根本不需要等待，或者可能只需要等待 1 微秒。

这里的结论是，你应该始终以逻辑正确性为目标。在代码中引入睡眠机制是方便调试并发程序的一种方法，但不是解决方案。

竞态是并发中最隐蔽的一类 bug ，因为它们可能会在代码投入生产数年之后才出现。它们通常是由代码执行环境的变化或前所未有的事件引起的。在这些情况下，代码似乎是正确运作的，但实际上，操作很有可能是按顺序执行的。这个程序迟早会产生意想不到的结果。

## 原子（automatic）
当某个东西被认为是原子的，或具有原子性时，这意味着在它运行的context（上下文/环境，关于context这个词，我认为在计算机领域里翻译为环境/运行环境会更恰当）中，它是不可再分的，或不可中断的。
>原子：原为化学用语，指化学反应中不可再分的基本微粒

那么这意味着什么?为什么在处理并发代码时了解这一点很重要?

首先非常重要的是这个词 "context",某些东西在一个context(运行环境)中可能是原子的，但在另一个context中则不是。在进程的运行环境中是原子的操作，在操作系统的运行环境中可能不是原子的；在操作系统的运行环境中是原子的操作，在机器的运行环境中可能不是原子的；在机器的运行环境中是原子的操作，在应用程序的运行环境中可能不是原子的。换句话说，操作的原子性会根据当前定义的范围而改变。

这个事实对你有利也有弊!

在考虑原子性时，通常需要做的第一件事是定义可以认定操作为原子的context或范围。这是一切的基础。
>趣事
暂不翻译

让我们来看术语中的“不可再分”与“不可中断”，这些术语的意思是，在你定义的context中，原子性的东西会完整地发生，而不会受context中同时发生的任何东西所影响。还是有点拗口，来看一个例子：
```go
i++
```
这个例子简单到谁都能想出来，不过很容易解释原子性的概念。这看起来可能是原子的，但我们可以简单分析出几个操作：

•获取 i 的值。（译者注：retire：检索，个人认为有“取值”的意思）
• i 自增。
•存储i的值。

在你所定义的context中，这些操作每一个单独拿出来都是原子的，但三者的组合可能不是，还需要取决于你的context

这揭示了原子操作的一个有趣性质:将多个原子操作结合起来不一定会产生更大的原子操作。要使操作原子化取决于你希望它在哪个 context 中原子化，如果你的 context 是一个没有并发进程的程序，那么上述这段代码在该 context 中是原子的；如果你的context是一个并发的 goroutine ，且该goroutine 的 i 没有对其他的 goroutine 公开，那么这段代码是原子的

那么我们为什么要关心原子性呢？其重要性在于，如果某个东西是原子的，那么它在并发 context 中是隐式安全的，这使我们能构建逻辑正确的程序，甚至可以作为优化并发程序图的一种方式，正如我们稍后会看到的一样。

大多数语句都不是原子的，更不用说函数、方法和程序了。原子性是组成逻辑正确的程序的关键，但大多数语句都不是原子性的，我们该如何处理？稍后我们将更深入地讨论。不过简而言之，我们可以使用各种技术来强制实现原子性，然后技术就转变成了确定代码的哪些区域需要原子化，以及其颗粒度(granularity)上。我们将在下一节讨论其中一些挑战
>译者注：granularity（颗粒度）：详细程度，精度，层次，级别，细节……原指岩石颗粒的大小

## 内存访问同步

我们假设有一个数据竞争:
两个并发进程试图访问相同的内存区域，并且它们访问内存的方式不是原子的。我们对之前简单的数据竞争例子做了一些修改:
```go
var data int
go func() { data++}()
if data == 0 {
    fmt.Println("the value is 0.")
} else {
    fmt.Printf("the value is %v.\n", data)
}
```
我们在这里添加了一个else语句，这样无论 data 的值是多少，我们都会得到输出。请记住上面说过时，由于存在数据竞争，程序的输出将完全不确定。

事实上，程序中需要独占访问共享资源的部分有一个名称，叫做临界区。在这个例子中，我们有三个关键部分:
•我们的 goroutine ，使变量 data 自增。
•我们的 if 语句，检查 data 的值是否为 0 。
•我们的 fmt.Printf 语句，它会输出 data 的值。

有很多种方法来保护程序的临界区，Go在如何处理这个问题上有一些更好的思路，其中之一是在临界区之间同步访问内存。让我们看一看。

下面的不是惯用的 Go 代码(我也不建议你尝试这样解决你的数据竞争问题)，但它非常简单地演示了内存访问同步。如果本例中的任何类型、函数或方法对您来说是陌生的，那也没关系。重点关注`通过调用来同步内存访问`的概念。
```go
var memoryAccess sync.Mutex //①
var data int
go func() {
    memoryAccess.Lock() //②
    data++
    memoryAccess.Unlock() //③
}()
memoryAccess.Lock() //④
if data == 0 {
    fmt.Printf("the data is %v.\n", data)
} else {
    fmt.Printf("the data is %v.\n", data)
}
memoryAccess.Unlock() //⑤
//原文这段代码里的变量是 value ，但下面表述用的变量是 data
```
① 此处我们添加了一个变量，允许我们的代码同步访问变量 data 的内存。请看第三章的 The sync Package 复习一下 sync.Mutex 类型
② 此处我们声明，除非另有声明，否则我们的goroutine应该独占访问这个内存。
③ 此处我们声明goroutine在这个内存中已经结束了
④ 此处我们再次声明以下条件语句应该独占访问数据变量的内存。
⑤ 此处我们再次声明我们不再使用这个内存。

在本例中，我们为开发人员创建了一个约定。任何时候开发者想要访问变量 data 的内存，他们必须首先调用Lock（加锁）函数，当他们完成后，他们必须调用Unlock（释放锁）函数。这两个语句之间的代码可以对 data 具有独占访问权。我们已经成功地同步访问了内存。还要注意的是，如果开发者不遵守这个约定，我们就无法保证独占访问权。我们将在第85页的“Confinement（中断）”一节中再说回到这个观点
>译者注：个人认为同步有多种意思，一般日常所说的“同步”会认为是“保持一致”的意思。本书中的同步特指“线程同步”，即当有一个线程在对内存进行操作时，其他线程都不可以对这个内存地址进行操作，直到该线程完成操作， 其他线程才能对该内存地址进行操作，而其他线程又处于等待状态。

你可能已经注意到，虽然我们已经解决了我们的数据竞争，但实际上我们还没有解决我们的竞态！

本程序的操作顺序仍然是不确定的;我们只是把不确定性的范围缩小了一点。在这个例子中，要么 goroutine 先执行，要么 if 和 else 代码块先执行。我们仍然不知道在这个程序的给定执行语句中，哪个会先发生。稍后，我们将探讨适合解决这类问题的工具。
从表面上看，这似乎非常简单:如果发现有临界区，就添加 point 来同步对内存的访问!很容易,对吧?嗯……可以这么说

的确，你可以通过同步对内存的访问来解决一些问题，但正如我们刚刚看到的，这样不能自动解决数据竞争或逻辑正确性的问题。此外，它还会产生维护和性能问题。

注意，前面我们提到，我们已经创建了一个约定来声明我们需要对某些内存的独占访问。约定很好，但也很容易被忽视——尤其是在软件工程中，业务需求有时会超过严谨性。通过这种方式同步对内存的访问，你可以指望所有其他开发人员现在和将来都遵循相同的惯例。这是一个相当高的要求。值得庆幸的是，在本书的后面部分，我们还将探讨一些帮助同行们更成功的方法。

以这种方式同步对内存的访问也有性能上的影响。这部分的细节我们留到第47页的The sync Package章节检查sync包时再作介绍，你会了解到对Lock的调用会使我们的程序变慢。每次执行这些操作时，程序都会暂停一段时间。这就带来了两个问题:
•程序的临界区部分是否反复进入和退出?
•程序的临界区部分应该有多大?

要回答这两个问题是一门艺术，这也给同步访问内存增加了难度。
对内存的同步访问也与其他并发问题建模的技术有一些相同的问题，我们将在下一节讨论这些问题。
## 死锁、活锁与饥饿（Deadlocks, Livelocks, and Starvation）
前面的部分都是关于程序正确性的讨论，如果这些问题得到了正确的管理，那么程序将永远不会给出错误的结果。不幸的是，即使你成功地处理了这类问题，还有另一类问题需要处理:死锁、活锁和饥饿。这些问题都涉及到使你的程序在任何时候都在运行。如果处理不当，您的程序可能会进入一种停止运行的状态。

### 死锁
死锁程序是指所有并发进程都相互等待的程序。在这种状态下，如果没有外部干预，程序将永远无法恢复。

这听起来确实很可怕！Go运行时试图检测到部分的一些死锁(所有的goroutine必须被阻塞，或“睡眠”)，但这并不能帮助您防止死锁。

为了帮助你巩固死锁是什么的知识，让我们先看一个示例。同样的，请忽略掉你不知道的任何类型、函数、方法或包，只关注代码标注。
```go
type value struct {
    mu    sync.Mutex
    value int
}
var wg sync.WaitGroup
printSum := func(v1, v2 *value) {
    defer wg.Done()
    v1.mu.Lock() ①
    defer v1.mu.Unlock() ②
    time.Sleep(2*time.Second) ③ 
    v2.mu.Lock()
    defer v2.mu.Unlock()
    fmt.Printf("sum=%v\n", v1.value + v2.value)
}
var a, b value
wg.Add(2)
go printSum(&a, &b)
go printSum(&b, &a)
wg.Wait()
```
① 此处我们尝试进入输入值的临界区。
② 此处我们使用defer语句在printSum返回之前退出临界区。
③ 此处我们睡眠一段时间以模拟工作(并触发死锁)。

如果你试着运行这段代码，你可能会看到
```bash
fatal error: all goroutines are asleep - deadlock!
```
这是为什么呢?如果仔细观察，你会发现这段代码中有一个计时。下面是正在发生的事情的图示。方框表示函数，水平线表示这些函数的调用，竖条表示图形上方的函数的生命周期

是指上，我们创造了两个不能一起转动的齿轮：
我们第一次调用print Sum锁定了a，然后试图锁定b，但与此同时，我们第二次调用print Sum锁定了b，并试图锁定a。两个goroutine都无限地等待彼此。

>译者注：两个goroutine并行运行，第一个先锁定了a，第二个先锁定了b，由于作者在调用函数中使用了 sleep ，在函数访问第二个传入的参数前给了足够长的时间让 a 和 b 都分别被锁定了，第一个goroutine得等待第二个goroutine释放b才能继续去锁定b，同理第二个goroutine得等待第一个goroutine释放a才能继续去锁定a，所以会无限等待

这样图形化地展示死锁发生的原因时似乎很直观，不过我们现在有更严谨的定义。在1971年，Edgar Coffman在一篇论文中列举了死锁发生的条件。这些条件现在被称为Coffman（科夫曼）条件，是帮助检测、预防和纠正死锁的技术的基础。

Coffman条件如下:
互斥并发：进程在任意时刻对资源拥有独占权限。

等待条件：并发进程必须同时持有一个资源并等待一个额外的资源。

非抢占：由并发进程持有的资源只能被该进程释放，所以它满足这个条件。

循环等待：一个并发进程(P1)必须等待一系列其他并发进程(P2)，这些并发进程又依次等待它(P1)，所以它也满足最后一个条件

让我们检查一下设计的程序，并确定它是否满足所有四个条件:
1. printSum函数确实需要对a和b的独占权限，因此它满足这个条件。

2. 因为 printSum 持有 a 或 b ，并且正在等待另一个 b 或 a ，所以它满足这个条件。

3. 我们并没有让 goroutine 被抢占。

4. printSum的第一次调用正在等待第二次调用，反之亦然。

没错，我们亲手实现了死锁

这些规则也能让我们预防死锁。如果确保这些条件中至少有一个不成立，我们就可以防止死锁的发生。不幸的是，实际上这些条件很难推断出来，因此也很难预防。网络上充斥着大量来自像你我这样的开发人员的问题，想知道为什么一段代码会死锁。一旦有人指出问题所在就很明显了，但这通常需要一双慧眼。我们将在第18页的“确定并发安全性”一节中讨论为什么要这样做。

### 活锁
活锁是主动执行并发操作的程序，但是这些操作不会向前移动程序的状态。
你曾经在走廊里面对面地遇到一个人吗?她移到一边让你过去，但你也做了同样的事情。所以你又移到另一边，但她也做了同样的事情。想象这种情况一直持续下去，你就能理解活锁了。

让我们实际编写一些代码来帮助演示这个场景。首先，我们将设置几个辅助函数来简化示例。为了得到一个可以运行的示例，这里的代码使用了几个我们还没有涉及到的主题。我不建议您在完全掌握同步包之前尝试了解任何细节。相反，我建议遵循代码标注来理解高光，然后将注意力转向第二个代码块，它包含示例的核心。





